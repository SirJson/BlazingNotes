{
  "createdAt": "2018-12-09T05:16:00.000Z",
  "updatedAt": "2018-12-25T22:03:47.355Z",
  "content": "# The Spirit tutorial\n\nDon't worry, this is not about occult magic. As I'm developing the\n[spirit](https://crates.io/crates/spirit) crate, I've decided a small tutorial would really help people to use it. So,\nthis post serves a dual purpose: to show how to use the library (and why) and to\nask for help with it.\n\n## What does spirit do\n\nI've already tried to introduce it in a previous post. The purpose\ndidn't change since then, though some details did.\n\nIn short, when writing a daemon or a service, we have the ÔÇ×muscleÔÇ£ of the\napplication ÔÇÆ whatever we write the daemon for. And we have a whole lot of\ninfrastructure around that: logging, command line parsing, configuration. And\nwhile there are Rust libraries for all that, one needs nontrivial amount of\nboilerplate code to bridge all this together.\n\nSpirit aims to be this bridge. It takes care of signal handling, of combining\nmultiple pieces of configuration together with command line overrides, it allows\nfor reloading the configuration at runtime. In short, it is the glue nobody\nreally wants to write every time. It doesn't do much itself, it just ties the\nreadily available libraries together. The aim is to save time with the boring\nstuff and to provide the boring stuff with some bells and whistles one wouldn't\nreally care to write were it just for this one daemon.\n\n## Status of the library and what you can do\n\nThe library is past the very early experimental state. I even dare to use it in\na production software. The high level design will probably stay the same or very\nsimilar as it is, though the API itself might get some changes over time. It\nfeels like it helps a lot with the boilerplate in some cases.\n\nOn the other hand, big chunks of functionality are still missing and it feels\nawkward to use at times. There are likely bugs, the documentation is\nunsatisfactory and I'm just not good at writing useful log messages.\n\nIn other words, the library needs some users, experimentation and people willing\nto help with polishing, fixing, smoothing rough edges, etc. Opening issues about\nwhat doesn't work or what your use case is helps. Opening PRs to fix them, to\nfill in TODOs in documentation or to add tests helps even more. I have some\nideas what needs to be done (some of them more concrete than others). Some of\nthem are hard, some of them are easy. If you want to help out but don't know\nhow, please contact me (through [github issue][repo] or over the [email],\nbut it might take me a day or two to answer sometimes), I'll be glad to discuss\nwhat to do, how to do it or even help learning some Rust on the way if it's what\nyou need (or accept advice on how to do a nicer API if that's what you feel I\nneed ­ƒÿç). Every bit counts and it's definitely more work than I can do alone in\nmy free time.\n\nAlso, I've only tried it on Linux. It *should* work on other Unix systems.\nChanges to make it work on Windows might be needed.\n\n## How to use it\n\nBefore we start writing code, few words about how the library ÔÇÆ or more exactly,\ngroup of libraries ÔÇÆ works.\n\nThe core [`spirit`][spirit-crate] gives us a singleton [`Spirit`] object (well,\nit doesn't *force* you to have just one, it simply doesn't make any sense to\ncreate more) that manages the configuration of the application, its lifetime and\nsignals. The singleton is created by a [`Builder`] that allows to bootstrap it,\ngive it some basic information (like where to look for configuration files if\nnone are given on the command line or how does a default configuration look\nlike) and install bunch of callbacks for when configuration changes, when a\nsignal happens, when the application should terminate, etc. Then it runs a\nprovided application body with all these details taken care of.\n\nThe command line options and configuration are described by rust structures\nimplementing [`StructOpt`] and [`Deserialize`] respectively. They are type\nparameters of both [`Builder`] and [`Spirit`] and either can be plugged by the\n[`Empty`] structure if not needed.\n\nSo, how would this look like? Something like this:\n\n```rust\nuse std::time::Duration;\n\nuse serde_derive::Deserialize;\nuse spirit::{Empty, Spirit};\n\nfn default_interval() -> Duration {\n    Duration::from_secs(1)\n}\n\n#[derive(Clone, Debug, Default, Deserialize)]\nstruct Cfg {\n    message: String,\n    #[serde(with = \"serde_humanize_rs\", default = \"default_interval\")]\n    interval: Duration,\n}\n\nfn main() {\n    Spirit::<Empty, Cfg>::new()\n        .on_terminate(|| println!(\"Good bye\"))\n        .run(|spirit| {\n            while !spirit.is_terminated() {\n                let cfg = spirit.config();\n                println!(\"{}\", cfg.message);\n                std::thread::sleep(cfg.interval);\n            }\n            Ok(())\n        });\n}\n```\n\nThen, if you create a configuration file with this content:\n\n```toml\nmessage = \"Hello\"\ninterval = \"2s\"\n```\n\nAnd run it:\n\n```\ncargo run -- cfg.toml\n```\n\nIt'll keep saying `Hello` all over, until you press `CTRL+C`. Then it'll say\n`Good bye` and exit. If you change the configuration file (while the program is\nstill running) and send a SIGHUP to it, it'll adapt to it ÔÇÆ it'll start saying\nthe new message if you changed that.\n\nThere are few things of note here:\n* The [`serde_humanize_rs`] thing allows us to write durations in more human\n  fashion, with units. Nothing related to [`spirit`][spirit-crate], but handy\n  anyway.\n* We run the [`spirit.config`][config] every iteration to get us an up to date\n  config. This call is very cheap ÔÇÆ it is just a smart pointer into the version\n  spirit holds for us. If we took one at the beginning, it would hold the\n  *original* config from start of the application. The smart pointer returned\n  from the `config` call doesn't change under our hands, therefore we can get a\n  new one when we are ready for it, but it'll be in consistent state (eg. fully\n  old or fully new).\n* If you play with it, you'll discover that despite us not asking for any\n  command line options, we already got *some*, mostly to provide `--help` and to\n  specify configuration or configuration overrides.\n* You can pass multiple configuration files. They are composed together, the\n  latter ones overriding the earlier ones. So you can have a company-global\n  configuration and machine-specific overrides, for example.\n* With a little more configuration, we could also pass configuration\n  *directories*. Every time the configuration is loaded, they are scanned for\n  configuration files and these are loaded. You know, the style that you have\n  eg. `/etc/cron.d` folder and cron loads all of them. You could ask spirit to\n  extract configuration from the environment variables, to support deployment in\n  docker cloud.\n* If something goes wrong, the application will just *silently exit*. This is\n  because [`Spirit`] uses [`log`] under the hood and we haven't set any logging\n  up. We'll look into it soon.\n* When we press `CTRL+C`, it doesn't exit right away, but after it waits the\n  interval. We could do something about that, like having a [mpsc], doing\n  [`recv_timeout`] in the loop and sending an ÔÇ×interruptÔÇ£ signal in the\n  [`on_terminate`] hook. But let's leave it as an exercise for the reader.\n\n### Active and passive configurations\n\nSpirit by default assumes than *any* part of configuration can change at\nruntime. For some daemons this is a must, because shutting them down is a big\nhassle (postgress can take tens of minutes to start up again so you don't want\nto restart it just to tweak the configuration a bit, apache lets you add new\nvirtual hosts without stopping serving the previous ones). Sometimes it is just\nconvenience ÔÇÆ if you have a service in production and it is misbehaving, it is\nnice to be able to turn debug logging on in the relevant part while it is still\nrunning.\n\nIf you don't like it, you can either turn the background signal processing\n[thread off][build], or you can [selectively warn][immutable_cfg] the user about\npieces of configuration you're not able to adapt to.\n\nIf you do like it, you can adapt to new configuration in two ways. We've seen\nthe passive way above. Simply, the next time the configuration is needed, a new\nvalue automagically appears in the configuration and we just use it. That's the\neasy way, but not always enough.\n\nThe active way is registering a callback to be notified of the changes. There\nare actually two, with different power. The simpler but less flexible one is\n[`on_config`]. It is just told the configuration changed when it already\nhappened, like this:\n\n```rust\n.on_config(|cmd_line, new_cfg| {\n    debug!(\"Current cmdline: {:?} and config {:?}\", cmd_line, new_cfg);\n})\n```\n\nThe more complex one is [`config_validator`]. That one is run as part of loading\nthe configuration and it can *refuse* it. In such case, errors are printed and\nthe old configuration stays until the user fixes the problem and tries to load\nit again. It also can tweak the new configuration before it is applied (like,\nputting values within limits and warning about it instead of outright refusing\nit) and it can schedule an action to happen once all the validators have run,\neither on success or failure. The idea is, some configuration needs to be *tried\nout* to see if it works, so the success allows to install it and failure to roll\nit back in case some other validator said no.\n\n### Helpers\n\nA helper is something that modifies a builder. A `FnOnce(Builder) -> Builder` is\na helper, but more things can be so. This allows parts of configuration to plug\nthemselves into the builder without knowing each other. It also allows libraries\nto provide pieces of functionality that can be plugged in with the [`with`]\nmethod. That allows the library to register multiple callbacks at once, in\ninterdependent manner.\n\nThere are also configuration helpers. These are kind of building blocks for the\nconfiguration, a fragment that can be put in there. Then, when registered with\nan extractor function (one that extracts the fragment out of the whole\nconfiguration), an action (what that is depends on the type of fragment) and a\nname, they do the magic to handle reloading that bit of configuration.\n\nAn example can be a fragment to configure a TCP listening socket. The action\nwould be what happens with a new connection. All the rest ÔÇÆ binding to a port,\nconfiguring a lot of details about how to listen and doing all the accepting,\nshutting it down when it changes and building a new one, etc, is done by the\nhelper.\n\nThe other example is logging.\n\n### Logging\n\nWhile there are few helpers directly in [`spirit`], most of them live in other\nrelated crates. So, let's go shopping ÔÇÆ we want [`spirit-log`] here to give us\nlogging.\n\nSo, first, we import it:\n\n```rust\nuse spirit_log::{Cfg as Logging, Opts as LogOpts};\n```\n\nThen, we put the fragments into our configuration structure. We also want to put\nthe `LogOpts` into our command line options structure (we have to create one,\n`Empty` is no longer good enough). We wouldn't have to, but it allows the user\nto override logging on command line, which is convenient when trying things out.\n\n```rust\n#[derive(Clone, Debug, StructOpt)]\nstruct Opts {\n    #[structopt(flatten)]\n    log: LogOpts,\n}\n\n#[derive(Clone, Debug, Default, Deserialize)]\nstruct Cfg {\n    message: String,\n    #[serde(with = \"serde_humanize_rs\", default = \"default_interval\")]\n    interval: Duration,\n\n    #[serde(flatten)]\n    log: Logging,\n}\n```\n\nCool, so now we can add this to our configuration, if we want to log both to\nstderr and a file, with different options.\n\n```toml\n[[logging]]\nlevel = \"DEBUG\"\ntype = \"stderr\"\n\n[[logginng]]\nlevel = \"INFO\"\ntype = \"file\"\nfilename = \"/tmp/example.log\"\nclock = \"UTC\"\nformat = \"machine\"\n```\n\nBut this'll only allow *parsing* the configuration. We need to make the\nconfiguration active. First, let's write our extractors ÔÇÆ little functions that\ntake the whole configuration or command line structure and produce the relevant\nbit. We could use an in-place closure, but the expected signature allows us to\nactually write it as a method of the structure, which looks more tidy.\n\n```rust\nimpl Opts {\n    fn logging(&self) -> LogOpts {\n        self.log.clone()\n    }\n}\n\nimpl Cfg {\n    fn logging(&self) -> Logging {\n        self.log.clone()\n    }\n}\n```\n\nAnd then just put it into the builder. That one will take care of initializing\nour loggers and replacing them when the configuration changes. It'll even reopen\nthe log files on `SIGHUP`, which makes integration with [logrotate] seamless.\n\n```rust\n.config_helper(Cfg::logging, Opts::logging, \"logging\")\n```\n\n### Other helpers\n\nBesides logging, there are already helpers for other things:\n\n* Daemonization (going into background), in [`spirit-daemonize`].\n* Some tokio integrations, mostly running the runtime and listening sockets, in\n  [`spirit-tokio`]. Things like connection pools are planned.\n* Hyper integration, which allows configuring a hyper server (or multiple ones),\n  in [`spirit-hyper`].\n\nAnd there's a long wish-list for other helpers and integrations. Not all of them\nare obvious how to do or thought through. This is part of why it seems a lot of\nwork to make Spirit more usable ÔÇÆ it would be great if one could just come,\nthrow several configuration helpers/fragments in there and be done with\neverything but the application specific logic.\n\n* Something that can dump parsed configuration (and exit), eg. `--dump-config`.\n* Something that can examine the configuration structure and show it to the user\n  or generate some kind of annotated default configuration. A possible venue\n  there is either creating additional trait to describe the documentation, or\n  try to extract the structure from [`Deserialize`] through a fake\n  deserialization format.\n* Metrics. I'm experimenting with [`dipstick`], but different one is of course\n  an option (or having multiple ones).\n* Some applications might prefer [`slog`] over [`log`].\n* [`reqwest`] ÔÇÆ keeping a global, configured HTTP client around.\n* Some integration with [`sentry`]. However, reconfiguring that one at runtime\n  poses challenges.\n* Both [`spirit-tokio`] and [`spirit-hyper`] would benefit from something that\n  can add TLS encryption, possibly as an intermediate layer.\n\nAnd I'm sure people will discover more things that could be reusable and shared\nbetween people.\n\n### The full example\n\nIt's still longer than I'd have liked, but considering how much functionality it\nprovides already (eg. the logging configuration, composing of configuration,\netc), it's not that bad. Some derive might help with that (but someone would\nhave to write it first).\n\n```rust\nuse std::time::Duration;\n\nuse log::debug;\nuse serde_derive::Deserialize;\nuse spirit::Spirit;\nuse spirit_log::{Cfg as Logging, Opts as LogOpts};\nuse structopt::StructOpt;\n\nfn default_interval() -> Duration {\n    Duration::from_secs(1)\n}\n\n#[derive(Clone, Debug, StructOpt)]\nstruct Opts {\n    #[structopt(flatten)]\n    log: LogOpts,\n}\n\n#[derive(Clone, Debug, Default, Deserialize)]\nstruct Cfg {\n    message: String,\n    #[serde(with = \"serde_humanize_rs\", default = \"default_interval\")]\n    interval: Duration,\n\n    #[serde(flatten)]\n    log: Logging,\n}\n\nimpl Opts {\n    fn logging(&self) -> LogOpts {\n        self.log.clone()\n    }\n}\n\nimpl Cfg {\n    fn logging(&self) -> Logging {\n        self.log.clone()\n    }\n}\n\nfn main() {\n    Spirit::<Opts, Cfg>::new()\n        .on_terminate(|| println!(\"Good bye\"))\n        .config_helper(Cfg::logging, Opts::logging, \"logging\")\n        .on_config(|cmd_line, new_cfg| {\n            debug!(\"Current cmdline: {:?} and config {:?}\", cmd_line, new_cfg);\n        })\n        .run(|spirit| {\n            while !spirit.is_terminated() {\n                let cfg = spirit.config();\n                println!(\"{}\", cfg.message);\n                std::thread::sleep(cfg.interval);\n            }\n            Ok(())\n        });\n}\n```\n\nAlso, there's a bit longer [example] in the repository, showing possibilities of\nsome more helpers.\n\n[repo]: https://github.com/vorner/spirit\n[email]: mailto:vorner@vorner.cz\n[`Spirit`]: https://docs.rs/spirit/~0.2/spirit/struct.Spirit.html\n[`Builder`]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html\n[`StructOpt`]: https://docs.rs/structopt/~0.2/structopt/trait.StructOpt.html\n[`Deserialize`]: https://docs.rs/serde/~1/serde/trait.Deserialize.html\n[`Empty`]: https://docs.rs/spirit/~0.2/spirit/struct.Empty.html\n[`serde_humanize_rs`]: https://crates.io/crates/serde-humanize-rs\n[config]: https://docs.rs/spirit/~0.2/spirit/struct.Spirit.html#method.config\n[`log`]: https://crates.io/crates/log\n[mpsc]: https://doc.rust-lang.org/std/sync/mpsc/index.html\n[`recv_timeout`]: https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv_timeout\n[`on_terminate`]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html#method.on_terminate\n[build]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html#method.build\n[immutable_cfg]: https://docs.rs/spirit/~0.2/spirit/helpers/fn.immutable_cfg.html\n[`on_config`]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html#method.on_config\n[`config_validator`]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html#method.config_validator\n[`with`]: https://docs.rs/spirit/~0.2/spirit/struct.Builder.html#method.with\n[`spirit-log`]: https://crates.io/crates/spirit-log\n[logrotate]: https://linux.die.net/man/8/logrotate\n[`dipstick`]: https://crates.io/crates/dipstick\n[`spirit-daemonize`]: https://crates.io/crates/spirit-daemonize\n[`spirit-tokio`]: https://crates.io/crates/spirit-tokio\n[`spirit-hyper`]: https://crates.io/crates/spirit-hyper\n[`reqwest`]: https://crates.io/crates/reqwest\n[example]: https://github.com/vorner/spirit/tree/master/examples/hws-complete\n",
  "folder": "c437ee5aa512409d438f",
  "title": "The Spirit tutorial",
  "type": "MARKDOWN_NOTE",
  "tags": [
    "How-to"
  ],
  "isStarred": false,
  "isTrashed": false
}
